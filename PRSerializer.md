# Current version #
0.1.2

# Introduction #
Python Pickle and cPickle are not safe, because unpickling from an untrusted source can be very harmful.
PRSerializer solve this security issue, unpickling only safe builtin objects and trusted class instances. It's faster and, like old pickle implementations, uses only printable ASCII chars (see [Notes](#Notes.md) below).

# Note #
PRSerializer supports pydoc, and is fully documented. You can generate your own module documentation using pydoc calling `pydoc -w PRSerializer` on module directory.

# Usage #
Like pickle, this module has both dumps and loads functions. But serializable classetypes must be registered for security reasons and they must use `__getstate__` and `__setstate__` methods for pickling (see [Design](#Design.md) below).

Due we need to register classtypes, and don't class instances, we can register them right after definition. For example:
```
from PRSerializer import register

class Example(object):
    a = 5
    b = 6

    def __getstate__(self):
        return (a, b)

    def __setstate__(self, values):
        self.a = values[0]
        self.b = values[1]

register(Example)
```
Now, after 0.1.1 release, we can use a class decorator if we're using Python 2.6 or newer version.
```
from PRSerializer import serializable

@serializable
class Example(object):
    a = 5
    b = 6

    def __getstate__(self):
        return (a, b)

    def __setstate__(self, values):
        self.a = values[0]
        self.b = values[1]

```

## Methods ##
  * `register( classtype_object [, str_class_alias] )`
  * `Classes.register( classtype_object [, str_class_alias] )`
> > Receives any class type (not an instance), and it will be assumed as serializable by Serializer.
> > Received classtypes must have both `__getstate__` and `__setstate__` methods, `__getstate__` must return a serializable object that `__setstate__` will receive when unserializing.
> > Given alias, if given, will be used on serialized string instead the class name.

  * `serializable( classtype_object [, str_class_alias] )`
  * `Classes.serializable( classtype_object [, str_class_alias] )`
> > The same as register and Classes.register above, but now they return the given class instance, which allows use them as class decorators (on Python 2.6+).

  * `Classes.serial ( obj, __getstate__serializer_callback, int_level)`
  * `Classes.unserial ( serial_str, __getstate__unserializer_callback, int_level)`
> > Used, internally, by Serializer to serial and unserial class instances.

  * `dumps( serializable_object [, unused_protocol ] )`
  * `Serializer.dumps( serializable_object [, unused_protocol ] )`
> > Receives a supported object or inherited from supported.
> > Supported types are:
> > > bool, None, str, int, long, float, complex, list, tuple, xrange, dict

> > Also **supports class instances** when its classtypes are registered using `Classes.register` classmethod, or module-level `register` function.

  * `loads( serialized_str )`
  * `Serializer.loads( serialized_str )`
> > Receives a serialized string (generated by dumps) and convert them to Python objects. When a class object is loaded and it's not registered on Classes, it will raise an error.

## Exceptions ##
  * `ClassRegistrationError`
> > Raises when there is an error in a Classes method.

  * `SerializationError`
> > Raises when trying to serialize and unsuported object or non-registered class instance.

  * `UnserializationError`
> > Raises when there is an error when trying to unserialize an string. It commonly raises when trying to load a malformed string which is not generated by the module itself.

## Example ##

```
from PRSerializer import register, loads, dumps

class MyClass(object):
    atribute1 = True
    atribute2 = None

    def __init__(self):
        self.atribute2 = xrange(1000)
        # PRSerializer recognizes xrange natively, so it's a lot faster than range's lists.

    def __getstate__(self):
        # Required. This method must return which will be serialized.
        return (self.atribute1, self.atribute2)

    def __setstate__(self,o):
        # Required. This method receives unserialized data and use them.
        self.atribute1 = o[0]
        self.atribute2 = o[1]

# Classtype registration
register(MyClass)

# Using our serializable class...
instance = MyClass()
instance.atribute1 = "Text string" 

# Do serialize
a = dumps(instance)
print "PRSerializer output:",a

# We unserialize objects from string
b = loads(a)
print "Instance:",repr(b), repr(b.__dict__)
```

# Design #
This info is about how this serializer works internally, and its core design. You can use it knowing nothing about that.
  * Serializing
    * When object is sended to `dumps`, this algorithm check if is instance of some common Python builtin types and, recursively if iterable, converts it to an string.
    * The serialized string is hardly human readable because, for optimization reasons, lists and tuples are serialized as lists where separators contains on which recursion level are its items, for example:
> > > `[1,2,"hi",6]`
      * Will be serialized as:
> > > > `li1;0;i2;0;shi;0;i6`
    * All serialized items are prefixed with an unique char which identify its type. They're:
      * **s** str
      * **u** unicode as escaped ASCII str
      * **t** True
      * **f** False
      * **n** None
      * **z** int zero
      * **i** int
      * **a** float
      * **g** long
      * **j** complex
      * **x** xrange (xrange are handled natively for performance reasons)
      * **r** range (range are automatically detected from sequential int lists)
      * **p** tuple
      * **o** serialized class instance
      * **l** list
      * **d** dict
    * List, tuples, and dictionaries contains info about its levels, inside its item separators:
      * For example, this complex list:
> > > > `[[1,2,"hi",6],{"first":1,"second":2}]`
      * Will be serialized as:
> > > > `lli1;1;i2;1;shi;1;i6;0;dssecond:i2;1;sfirst:i1`
      * Which means:
        * list
          * list
            * int 1
            * level 1 separator
            * int 2
            * level 1 separator
            * str hi
            * level 1 separator
            * int 6
          * level 0 separator
          * dict
            * str second : int 2
            * level 1 separator
            * str first : int 1
    * Due serialization's format nature, all colons and semicolons on strings will be escaped.
      * For example, this string:
> > > > `Hi: We're strange;`
      * Will be serialized as:
> > > > `sHi&d We're strange&c`
    * Class instances are not really serialized at all, we only serialize some supported builtin objects, and that's the reason we need a `__getstate__` method which return them (or other serializable class instances whose `__getstate__` will do).
      * For example, an instance of class "Example", whose `__getstate__` method returns:
> > > > `(5,6)`
      * Will be serialized as:
> > > > `oExample:pi5;0;i6`
    * Before serializing a class instance, the algorithm makes sure it has been previously registered. It will raise `SerializationError` exception if it didn't. It's not only intended for safe coding, we really need knowing what is the classtype and its alias.

  * Unserializing
    * Serialization is fast, because serial strings are splited and parsed recursively. The heavy use of Python string's split method is intentionally: It's very fast because its functionality is implemented using cPython, inside the Python's core.
    * All serialized items are translated into Python objects, recursively, depending on it's first char.
    * We have a huge performance bottleneck with supported iterable objects (lists, tuples and dictionaries) because every item, once splitted, needs being parsed individually. But it's still faster than Pickle implementation.
    * When a class instance is unserialized, a new class is created using its `__new__` method if available (when a class inherits from object) or its `__init__` constructor, and then its `__setstate__` method is called with its serialized data as parameter.


# Notes #
  * It's simple because its core is coded on less than 200 lines.
  * It's pure-Python, so it's performance is not great, and its near two times faster unserializing than serializing.
  * It's safe, because it only handles some python builtin types and specified clases with handler methods.
  * It's faster than pickle when serializing (note that no python code can compete with C code, so cPickle is obviously faster).
  * Shorter output than pickle on old protocols (0 and 1), but a bit longer than last one (protocol 2 on 2.6), but works better with compresion than pickle.
  * Uses only printable characters, and unicode strings are escaped.
  * After 0.1.1 release, it can handle lists, generated by range, efficiently, in the same way xrange objects are handled, saving a lot of resources. But xrange use is still better due Python itself optimization tips.